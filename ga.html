
<html>
<body>

    <h1 id="pop"></h1>
    <h1 id="gen"></h1>
    <h1 id="fitness"></h1>
    <h1 id="color"></h1>
    <h1 id="sides"></h1>
	<canvas id="polygons"></canvas>
	<script>

	const maxSides = 20
    const targetSides = 4


    let targetColor = [255, 0, 0]
    
    let genCount = 0
    let popSize = 1500
    let seed = seedGeneration(popSize)

	species(seed, popSize)
	drawGeneration(document.getElementById("polygons"), seed)

    document.getElementById("pop").innerHTML = `Population of ${popSize}`
    document.getElementById("color").innerHTML = `Ideal Color <div style='display:inline-block;height: 50px; width: 50px; background-color: rgb(${targetColor[0]}, ${targetColor[1]}, ${targetColor[2]})'></div>`
    document.getElementById("sides").innerHTML = `Ideal Sides of ${targetSides}`
    function species(generation, size) {
        let generationalFitness = 9999
        let interval = setInterval(() => {
            if (generationalFitness == 0) {
                console.log("Final", generation)
                return clearInterval(interval)
            }

            genCount++
            let newGeneration = selectFromGeneration(generation, popSize)
            generation = newGeneration
            generationalFitness = calculateGenerationalFitness(generation)

		    drawGeneration(document.getElementById("polygons"), generation)
            document.getElementById("gen").innerHTML = `Generation ${genCount}`
            document.getElementById("fitness").innerHTML = `Generational fitness of ${generationalFitness}`
        }, 500)

    }

    function calculateGenerationalFitness(generation) {
        return generation.reduce((a, b) => [0, 0, 0, 0, a[4] + b[4]], [0, 0, 0, 0, 0])[4]
    }


	function selectFromGeneration(generation, popSize) {
		generation.splice(generation.length - generation.length * .05, generation.length)

        // TODO: Do not just breed the fittest, randomly select those to breed
        //let parents = selectParents(generation)
        let parents = generation

        if (parents.length % 2 != 0) parents.pop() // Sorry :( 

        return reproduce(parents, popSize).map(o => assignFitness(o)).sort(sortByFitness)

	}


    function reproduce(parents, popSize) {

        let children = []
        let currentParentIndex = 0
        while (popSize > 0) {
            let parentIndices = randomParentIndices(parents.length)
            console.log(parentIndices, parents.length)
            children.push(child([parents[parentIndices[0]], parents[parentIndices[1]]]))
            popSize--
        }

        return children

    }

    function randomParentIndices(parentsLength) {
        let one = randomBetween(parentsLength - 1, 0)
        let two = randomBetween(parentsLength - 1, 0)

        if (one == two) return randomParentIndices(parentsLength)
        else return [one, two]
    }

    function child(parents) {
        let child = []
        for (var i = 0; i < 4; i++) {
            if (coinFlip()) child.push(parents[1][i])
            else child.push(parents[0][i])
        }
        return mutate(child)
    }

    function mutate(child) {
        let index = Math.floor(Math.random() * 4)
        let value = child[index]
        if (randomBetween(10000, 1) < 10) {
            if (index < 1) { // Sides need to be modified differently
                value += coinFlip() ? 1 : -1
                if (value < 3) value = 3
                child[index] = value
            } else {
                value += coinFlip() ? 1 : -1
                //value = coinFlip() ? randomColorValue() : value
                child[index] = value
            }
        }
        return child
    }

	function assignFitness(org) {
		let desiredColor = [255, 0, 0]

		let color = org.slice(1, 4)
		let numberOfSides = org[0]

		let colorDiff = color.map((x, i) => Math.abs(x - desiredColor[i])).reduce((a, b) => a + b, 0)

		let numberOfSidesDiff = Math.abs(numberOfSides - targetSides)

        let fitness = colorDiff + (numberOfSidesDiff * 5) 
        if (fitness > 0) org.push(fitness)
        else org.push(0)

		return org
	}

	function sortByFitness(a, b) {
        if (a[4] > b[4]) return 1
		if (a[4] < b[4]) return -1
		if (a[4] == b[4]) return 0
	}

	function seedGeneration(popSize) {
		let pop = []

		// Random RGB values
		while (popSize > 0) {
			let colors = 3
			let org = [randomSidesValue(maxSides)]
			while (colors > 0) {
				org.push(randomColorValue())
				colors--
			}
			popSize--
			pop.push(org)
		}
        return pop.map(o => assignFitness(o)).sort(sortByFitness)
	}

    function randomBetween(hi, lo) {
        return Math.floor(Math.random() * hi) + lo
    }

    function coinFlip() {
        return (Math.floor(Math.random() * 2) + 1) % 2 == 0
    }

    function randomNumberOfChildren() {
        return Math.floor(Math.random() * 6) + 1
    }

	function randomColorValue() {
		return Math.floor(Math.random() * 256)
	}

	function randomSidesValue(maxSides) {
		return Math.floor(Math.random() * maxSides) + 3
	}

	function drawGeneration(el, gen) {

		let opts = {
			size: 25,
			startX: 25,
			startY: 50,
			rowLength: 50
		}
		opts.y = opts.startY
		opts.x = opts.startX

		let ctx = el.getContext("2d")


		el.height = (gen.length / opts.rowLength) * opts.y + opts.size
        el.height += 100
		el.width = (opts.size * 2) * opts.rowLength
		gen.forEach((g, i) => drawOrganism(ctx, g, i + 1, opts))
	}

	function drawOrganism(ctx, org, n, opts) {
		// Shamefully adapted from http://scienceprimer.com/drawing-regular-polygons-javascript-canvas
		let x = opts.x
		let y = opts.y
		let size = opts.size


		ctx.beginPath();
		ctx.moveTo (x + size * Math.cos(0), y +  size *  Math.sin(0));

		for (var i = 1; i <= org[0];i += 1) {
    		ctx.lineTo (x + size * Math.cos(i * 2 * Math.PI / org[0]), y + size * Math.sin(i * 2 * Math.PI / org[0]));
		}

		ctx.save()
		ctx.save()
		ctx.fillStyle = `rgb(${org[1]}, ${org[2]}, ${org[3]})`
		ctx.fill()
		ctx.restore()

		opts.x += opts.size * 2
		if (n % opts.rowLength == 0) {
			opts.y = (n * opts.startY) / opts.rowLength + opts.startY
			opts.x = opts.startX
		}
	}
	</script>
</body>	
</html>

